<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Apache Mesos: mesos::allocator::Allocator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemesos.html">mesos</a></li><li class="navelem"><a class="el" href="namespacemesos_1_1allocator.html">allocator</a></li><li class="navelem"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html">Allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmesos_1_1allocator_1_1Allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mesos::allocator::Allocator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic model of an allocator: resources are allocated to a framework in the form of offers.  
 <a href="classmesos_1_1allocator_1_1Allocator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2mesos_2allocator_2allocator_8hpp_source.html">allocator.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mesos::allocator::Allocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmesos_1_1allocator_1_1Allocator.png" usemap="#mesos::allocator::Allocator_map" alt=""/>
  <map id="mesos::allocator::Allocator_map" name="mesos::allocator::Allocator_map">
<area href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html" alt="mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;" shape="rect" coords="0,56,408,80"/>
<area href="classmesos_1_1internal_1_1tests_1_1TestAllocator.html" alt="mesos::internal::tests::TestAllocator&lt; T &gt;" shape="rect" coords="418,56,826,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aafc715605c23a31dcb511a6b5c2ac883"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#aafc715605c23a31dcb511a6b5c2ac883">Allocator</a> ()</td></tr>
<tr class="separator:aafc715605c23a31dcb511a6b5c2ac883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32e61251f0e0cbc9588c04e98347a3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a8b32e61251f0e0cbc9588c04e98347a3">~Allocator</a> ()</td></tr>
<tr class="separator:a8b32e61251f0e0cbc9588c04e98347a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab813725216eb1fdfc62b4e3f61c044f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#ab813725216eb1fdfc62b4e3f61c044f2">initialize</a> (const <a class="el" href="classDuration.html">Duration</a> &amp;allocationInterval, const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt;&gt; &amp;)&gt; &amp;offerCallback, const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;)&gt; &amp;inverseOfferCallback, const <a class="el" href="classOption.html">Option</a>&lt; std::set&lt; std::string &gt;&gt; &amp;fairnessExcludeResourceNames=<a class="el" href="structNone.html">None</a>())=0</td></tr>
<tr class="memdesc:ab813725216eb1fdfc62b4e3f61c044f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the allocator when the master starts up.  <a href="#ab813725216eb1fdfc62b4e3f61c044f2">More...</a><br/></td></tr>
<tr class="separator:ab813725216eb1fdfc62b4e3f61c044f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1f158adb9f7a6d7cc9f8afae44e859"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#abe1f158adb9f7a6d7cc9f8afae44e859">recover</a> (const int expectedAgentCount, const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="structQuota.html">Quota</a> &gt; &amp;quotas)=0</td></tr>
<tr class="memdesc:abe1f158adb9f7a6d7cc9f8afae44e859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the allocator of the recovered state from the master.  <a href="#abe1f158adb9f7a6d7cc9f8afae44e859">More...</a><br/></td></tr>
<tr class="separator:abe1f158adb9f7a6d7cc9f8afae44e859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbc103b21872ed885a45ac3d928c83d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a8dbc103b21872ed885a45ac3d928c83d">addFramework</a> (const FrameworkID &amp;frameworkId, const FrameworkInfo &amp;frameworkInfo, const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;used, bool active)=0</td></tr>
<tr class="memdesc:a8dbc103b21872ed885a45ac3d928c83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a framework to the Mesos cluster.  <a href="#a8dbc103b21872ed885a45ac3d928c83d">More...</a><br/></td></tr>
<tr class="separator:a8dbc103b21872ed885a45ac3d928c83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58e3a3025d3887ab1ab9267c9093188"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#ac58e3a3025d3887ab1ab9267c9093188">removeFramework</a> (const FrameworkID &amp;frameworkId)=0</td></tr>
<tr class="memdesc:ac58e3a3025d3887ab1ab9267c9093188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a framework from the Mesos cluster.  <a href="#ac58e3a3025d3887ab1ab9267c9093188">More...</a><br/></td></tr>
<tr class="separator:ac58e3a3025d3887ab1ab9267c9093188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b5e4ab25ef87eb74763c10cfc21850"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a60b5e4ab25ef87eb74763c10cfc21850">activateFramework</a> (const FrameworkID &amp;frameworkId)=0</td></tr>
<tr class="memdesc:a60b5e4ab25ef87eb74763c10cfc21850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates a framework in the Mesos cluster.  <a href="#a60b5e4ab25ef87eb74763c10cfc21850">More...</a><br/></td></tr>
<tr class="separator:a60b5e4ab25ef87eb74763c10cfc21850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d8fc901322dde7d91037930c77f72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#afe9d8fc901322dde7d91037930c77f72">deactivateFramework</a> (const FrameworkID &amp;frameworkId)=0</td></tr>
<tr class="memdesc:afe9d8fc901322dde7d91037930c77f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivates a framework in the Mesos cluster.  <a href="#afe9d8fc901322dde7d91037930c77f72">More...</a><br/></td></tr>
<tr class="separator:afe9d8fc901322dde7d91037930c77f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e33c8def42553ba5435809dcae5b0a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a55e33c8def42553ba5435809dcae5b0a">updateFramework</a> (const FrameworkID &amp;frameworkId, const FrameworkInfo &amp;frameworkInfo)=0</td></tr>
<tr class="memdesc:a55e33c8def42553ba5435809dcae5b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates capabilities of a framework in the Mesos cluster.  <a href="#a55e33c8def42553ba5435809dcae5b0a">More...</a><br/></td></tr>
<tr class="separator:a55e33c8def42553ba5435809dcae5b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12346eed9894458805e180b9d6cb6424"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a12346eed9894458805e180b9d6cb6424">addSlave</a> (const SlaveID &amp;slaveId, const SlaveInfo &amp;slaveInfo, const std::vector&lt; SlaveInfo::Capability &gt; &amp;capabilities, const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;unavailability, const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;total, const <a class="el" href="classhashmap.html">hashmap</a>&lt; FrameworkID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;used)=0</td></tr>
<tr class="memdesc:a12346eed9894458805e180b9d6cb6424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or re-adds an agent to the Mesos cluster.  <a href="#a12346eed9894458805e180b9d6cb6424">More...</a><br/></td></tr>
<tr class="separator:a12346eed9894458805e180b9d6cb6424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7193bcacb52eaec201bf88e95f03acad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a7193bcacb52eaec201bf88e95f03acad">removeSlave</a> (const SlaveID &amp;slaveId)=0</td></tr>
<tr class="memdesc:a7193bcacb52eaec201bf88e95f03acad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an agent from the Mesos cluster.  <a href="#a7193bcacb52eaec201bf88e95f03acad">More...</a><br/></td></tr>
<tr class="separator:a7193bcacb52eaec201bf88e95f03acad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb21abe14f83ee609f459973bd31b05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#afeb21abe14f83ee609f459973bd31b05">updateSlave</a> (const SlaveID &amp;slave, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;oversubscribed=<a class="el" href="structNone.html">None</a>(), const <a class="el" href="classOption.html">Option</a>&lt; std::vector&lt; SlaveInfo::Capability &gt;&gt; &amp;capabilities=<a class="el" href="structNone.html">None</a>())=0</td></tr>
<tr class="memdesc:afeb21abe14f83ee609f459973bd31b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an agent.  <a href="#afeb21abe14f83ee609f459973bd31b05">More...</a><br/></td></tr>
<tr class="separator:afeb21abe14f83ee609f459973bd31b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2469bc7c28ab20a86cd2d198dd99e2cd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a2469bc7c28ab20a86cd2d198dd99e2cd">activateSlave</a> (const SlaveID &amp;slaveId)=0</td></tr>
<tr class="memdesc:a2469bc7c28ab20a86cd2d198dd99e2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates an agent.  <a href="#a2469bc7c28ab20a86cd2d198dd99e2cd">More...</a><br/></td></tr>
<tr class="separator:a2469bc7c28ab20a86cd2d198dd99e2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff6ddc4983c5495eb2fc26e2842114"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a4dff6ddc4983c5495eb2fc26e2842114">deactivateSlave</a> (const SlaveID &amp;slaveId)=0</td></tr>
<tr class="memdesc:a4dff6ddc4983c5495eb2fc26e2842114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivates an agent.  <a href="#a4dff6ddc4983c5495eb2fc26e2842114">More...</a><br/></td></tr>
<tr class="separator:a4dff6ddc4983c5495eb2fc26e2842114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961049fd776211cc762ad0e1e1c99321"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a961049fd776211cc762ad0e1e1c99321">updateWhitelist</a> (const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classhashset.html">hashset</a>&lt; std::string &gt;&gt; &amp;whitelist)=0</td></tr>
<tr class="memdesc:a961049fd776211cc762ad0e1e1c99321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the list of trusted agents.  <a href="#a961049fd776211cc762ad0e1e1c99321">More...</a><br/></td></tr>
<tr class="separator:a961049fd776211cc762ad0e1e1c99321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1124aace866719ed1e9ed45a068412"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a6d1124aace866719ed1e9ed45a068412">requestResources</a> (const FrameworkID &amp;frameworkId, const std::vector&lt; Request &gt; &amp;requests)=0</td></tr>
<tr class="memdesc:a6d1124aace866719ed1e9ed45a068412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests resources for a framework.  <a href="#a6d1124aace866719ed1e9ed45a068412">More...</a><br/></td></tr>
<tr class="separator:a6d1124aace866719ed1e9ed45a068412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f405bd54c1c1782a388cb28ca58b42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a42f405bd54c1c1782a388cb28ca58b42">updateAllocation</a> (const FrameworkID &amp;frameworkId, const SlaveID &amp;slaveId, const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;offeredResources, const std::vector&lt; Offer::Operation &gt; &amp;operations)=0</td></tr>
<tr class="memdesc:a42f405bd54c1c1782a388cb28ca58b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates allocation by applying offer operations.  <a href="#a42f405bd54c1c1782a388cb28ca58b42">More...</a><br/></td></tr>
<tr class="separator:a42f405bd54c1c1782a388cb28ca58b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997ec43933a7659b683d83c164bdd6db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt; <a class="el" href="structNothing.html">Nothing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a997ec43933a7659b683d83c164bdd6db">updateAvailable</a> (const SlaveID &amp;slaveId, const std::vector&lt; Offer::Operation &gt; &amp;operations)=0</td></tr>
<tr class="memdesc:a997ec43933a7659b683d83c164bdd6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates available resources on an agent based on a sequence of offer operations.  <a href="#a997ec43933a7659b683d83c164bdd6db">More...</a><br/></td></tr>
<tr class="separator:a997ec43933a7659b683d83c164bdd6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455bb50eb4548484969c42ada23cd8ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a455bb50eb4548484969c42ada23cd8ff">updateUnavailability</a> (const SlaveID &amp;slaveId, const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;unavailability)=0</td></tr>
<tr class="memdesc:a455bb50eb4548484969c42ada23cd8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates unavailability for an agent.  <a href="#a455bb50eb4548484969c42ada23cd8ff">More...</a><br/></td></tr>
<tr class="separator:a455bb50eb4548484969c42ada23cd8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b03a500abdf2f677f3fd9ea958d0690"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a9b03a500abdf2f677f3fd9ea958d0690">updateInverseOffer</a> (const SlaveID &amp;slaveId, const FrameworkID &amp;frameworkId, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;unavailableResources, const <a class="el" href="classOption.html">Option</a>&lt; InverseOfferStatus &gt; &amp;status, const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;filters=<a class="el" href="structNone.html">None</a>())=0</td></tr>
<tr class="memdesc:a9b03a500abdf2f677f3fd9ea958d0690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates inverse offer.  <a href="#a9b03a500abdf2f677f3fd9ea958d0690">More...</a><br/></td></tr>
<tr class="separator:a9b03a500abdf2f677f3fd9ea958d0690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09ffe12fe6dce0bb115d9988ddb61d1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classprocess_1_1Future.html">process::Future</a><br class="typebreak"/>
&lt; <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classhashmap.html">hashmap</a><br class="typebreak"/>
&lt; FrameworkID, <br class="typebreak"/>
mesos::allocator::InverseOfferStatus &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#af09ffe12fe6dce0bb115d9988ddb61d1">getInverseOfferStatuses</a> ()=0</td></tr>
<tr class="memdesc:af09ffe12fe6dce0bb115d9988ddb61d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the status of all inverse offers maintained by the allocator.  <a href="#af09ffe12fe6dce0bb115d9988ddb61d1">More...</a><br/></td></tr>
<tr class="separator:af09ffe12fe6dce0bb115d9988ddb61d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9719d532d6e866956062a3d8ad437781"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a9719d532d6e866956062a3d8ad437781">recoverResources</a> (const FrameworkID &amp;frameworkId, const SlaveID &amp;slaveId, const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;resources, const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;filters)=0</td></tr>
<tr class="memdesc:a9719d532d6e866956062a3d8ad437781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers resources.  <a href="#a9719d532d6e866956062a3d8ad437781">More...</a><br/></td></tr>
<tr class="separator:a9719d532d6e866956062a3d8ad437781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768bf53dbae88340e7f048659490ef2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a768bf53dbae88340e7f048659490ef2b">suppressOffers</a> (const FrameworkID &amp;frameworkId, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;role)=0</td></tr>
<tr class="memdesc:a768bf53dbae88340e7f048659490ef2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppresses offers.  <a href="#a768bf53dbae88340e7f048659490ef2b">More...</a><br/></td></tr>
<tr class="separator:a768bf53dbae88340e7f048659490ef2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2199d77c20843a5aa04b11c9bd93867d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a2199d77c20843a5aa04b11c9bd93867d">reviveOffers</a> (const FrameworkID &amp;frameworkId, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;role)=0</td></tr>
<tr class="memdesc:a2199d77c20843a5aa04b11c9bd93867d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revives offers to this framework for the specified role.  <a href="#a2199d77c20843a5aa04b11c9bd93867d">More...</a><br/></td></tr>
<tr class="separator:a2199d77c20843a5aa04b11c9bd93867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d46d24d46f7c9858ab58c027ecc7ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a06d46d24d46f7c9858ab58c027ecc7ca">setQuota</a> (const std::string &amp;role, const <a class="el" href="structQuota.html">Quota</a> &amp;quota)=0</td></tr>
<tr class="memdesc:a06d46d24d46f7c9858ab58c027ecc7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the allocator to set quota for the given role.  <a href="#a06d46d24d46f7c9858ab58c027ecc7ca">More...</a><br/></td></tr>
<tr class="separator:a06d46d24d46f7c9858ab58c027ecc7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4fb581525a58eaea748afaa87ccb40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a7c4fb581525a58eaea748afaa87ccb40">removeQuota</a> (const std::string &amp;role)=0</td></tr>
<tr class="memdesc:a7c4fb581525a58eaea748afaa87ccb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the allocator to remove quota for the given role.  <a href="#a7c4fb581525a58eaea748afaa87ccb40">More...</a><br/></td></tr>
<tr class="separator:a7c4fb581525a58eaea748afaa87ccb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed11fe06b6565b72c57ee9a88439f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a36ed11fe06b6565b72c57ee9a88439f5">updateWeights</a> (const std::vector&lt; WeightInfo &gt; &amp;weightInfos)=0</td></tr>
<tr class="memdesc:a36ed11fe06b6565b72c57ee9a88439f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the weight associated with one or more roles.  <a href="#a36ed11fe06b6565b72c57ee9a88439f5">More...</a><br/></td></tr>
<tr class="separator:a36ed11fe06b6565b72c57ee9a88439f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae12461b03c88e6fce8528488b50a47f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTry.html">Try</a>&lt; <a class="el" href="classmesos_1_1allocator_1_1Allocator.html">Allocator</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#ae12461b03c88e6fce8528488b50a47f5">create</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae12461b03c88e6fce8528488b50a47f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts either to create a built-in DRF allocator or to load an allocator instance from a module using the given name.  <a href="#ae12461b03c88e6fce8528488b50a47f5">More...</a><br/></td></tr>
<tr class="separator:ae12461b03c88e6fce8528488b50a47f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic model of an allocator: resources are allocated to a framework in the form of offers. </p>
<p>A framework can refuse some resources in offers and run tasks in others. Allocated resources can have offer operations applied to them in order for frameworks to alter the resource metadata (e.g. creating persistent volumes). <a class="el" href="classmesos_1_1Resources.html">Resources</a> can be recovered from a framework when tasks finish/fail (or are lost due to an agent failure) or when an offer is rescinded.</p>
<p>This is the public API for resource allocators. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aafc715605c23a31dcb511a6b5c2ac883"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mesos::allocator::Allocator::Allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b32e61251f0e0cbc9588c04e98347a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mesos::allocator::Allocator::~Allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a60b5e4ab25ef87eb74763c10cfc21850"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::activateFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activates a framework in the Mesos cluster. </p>
<p>Offers are only sent to active frameworks. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a5b3d9588e381592d7f3a7033c87e8023">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2469bc7c28ab20a86cd2d198dd99e2cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::activateSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activates an agent. </p>
<p>This is invoked when an agent reregisters. Offers are only sent for activated agents. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a839be3c9f14c390cd92e9a4fde43065b">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8dbc103b21872ed885a45ac3d928c83d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::addFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameworkInfo &amp;&#160;</td>
          <td class="paramname"><em>frameworkInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a framework to the Mesos cluster. </p>
<p>The allocator is invoked when a new framework joins the Mesos cluster and is entitled to participate in resource sharing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">used</td><td><a class="el" href="classmesos_1_1Resources.html">Resources</a> used by this framework. The allocator should account for these resources when updating the allocation of this framework. The allocator should avoid double accounting when yet unknown agents are added later in <code><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a12346eed9894458805e180b9d6cb6424" title="Adds or re-adds an agent to the Mesos cluster. ">addSlave()</a></code>.</td></tr>
    <tr><td class="paramname">active</td><td>Whether the framework is initially activated. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a2bada3270698413305fa2dd8cabca97f">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a12346eed9894458805e180b9d6cb6424"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::addSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlaveInfo &amp;&#160;</td>
          <td class="paramname"><em>slaveInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SlaveInfo::Capability &gt; &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;&#160;</td>
          <td class="paramname"><em>unavailability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhashmap.html">hashmap</a>&lt; FrameworkID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds or re-adds an agent to the Mesos cluster. </p>
<p>It is invoked when a new agent joins the cluster or in case of agent recovery.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slaveId</td><td>ID of the agent to be added or re-added. </td></tr>
    <tr><td class="paramname">slaveInfo</td><td>Detailed info of the agent. The slaveInfo resources correspond directly to the static &ndash;resources flag value on the agent. </td></tr>
    <tr><td class="paramname">capabilities</td><td>Capabilities of the agent. </td></tr>
    <tr><td class="paramname">total</td><td>The <code>total</code> resources are passed explicitly because it includes resources that are dynamically "checkpointed" on the agent (e.g. persistent volumes, dynamic reservations, etc). </td></tr>
    <tr><td class="paramname">used</td><td><a class="el" href="classmesos_1_1Resources.html">Resources</a> that are allocated on the current agent. The allocator should avoid double accounting when yet unknown frameworks are added later in <code><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a8dbc103b21872ed885a45ac3d928c83d" title="Adds a framework to the Mesos cluster. ">addFramework()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af21d8b1c164feddfc6a8550245028b06">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae12461b03c88e6fce8528488b50a47f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTry.html">Try</a>&lt;<a class="el" href="classmesos_1_1allocator_1_1Allocator.html">Allocator</a>*&gt; mesos::allocator::Allocator::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts either to create a built-in DRF allocator or to load an allocator instance from a module using the given name. </p>
<p>If <code><a class="el" href="classTry.html">Try</a></code> does not report an error, the wrapped <code>Allocator*</code> is not null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe9d8fc901322dde7d91037930c77f72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::deactivateFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deactivates a framework in the Mesos cluster. </p>
<p>Resource offers are not sent to deactivated frameworks. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#ab6bfe097b00b97e71e75bf34d2ee12b4">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4dff6ddc4983c5495eb2fc26e2842114"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::deactivateSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deactivates an agent. </p>
<p>This is triggered if an agent disconnects from the master. The allocator should treat all offers from the deactivated agent as rescinded. (There is no separate call to the allocator to handle this). <a class="el" href="classmesos_1_1Resources.html">Resources</a> aren't "recovered" when an agent deactivates because the resources are lost. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af67ff01f9c80915a5c2db609fcfd466c">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af09ffe12fe6dce0bb115d9988ddb61d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt; <a class="el" href="classhashmap.html">hashmap</a>&lt;SlaveID, <a class="el" href="classhashmap.html">hashmap</a>&lt;FrameworkID, mesos::allocator::InverseOfferStatus&gt; &gt; &gt; mesos::allocator::Allocator::getInverseOfferStatuses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the status of all inverse offers maintained by the allocator. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a9c99e1ef89e81035b1e3656ca632628f">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab813725216eb1fdfc62b4e3f61c044f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDuration.html">Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>allocationInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt;&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>offerCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inverseOfferCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::set&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fairnessExcludeResourceNames</em> = <code><a class="el" href="structNone.html">None</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the allocator when the master starts up. </p>
<p>Any errors in initialization should fail fast and result in an ABORT. The master expects the allocator to be successfully initialized if this call returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocationInterval</td><td>The allocate interval for the allocator, it determines how often the allocator should perform the batch allocation. An allocator may also perform allocation based on events (a framework is added and so on), this depends on the implementation. </td></tr>
    <tr><td class="paramname">offerCallback</td><td>A callback the allocator uses to send allocations to the frameworks. </td></tr>
    <tr><td class="paramname">inverseOfferCallback</td><td>A callback the allocator uses to send reclaim allocations from the frameworks. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af156a0733bc92af96852aa09df8138b5">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abe1f158adb9f7a6d7cc9f8afae44e859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::recover </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>expectedAgentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="structQuota.html">Quota</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quotas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the allocator of the recovered state from the master. </p>
<p>Because it is hard to define recovery for a running allocator, this method should be called after <code><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#ab813725216eb1fdfc62b4e3f61c044f2" title="Initializes the allocator when the master starts up. ">initialize()</a></code>, but before actual allocation starts (i.e. <code><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a12346eed9894458805e180b9d6cb6424" title="Adds or re-adds an agent to the Mesos cluster. ">addSlave()</a></code> is called).</p>
<p>TODO(alexr): Consider extending the signature with expected frameworks count once it is available upon the master failover.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quotas</td><td>A (possibly empty) collection of quotas, keyed by their role, known to the master. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#aa38e6a84a1dc03b531897ea1ee7745f1">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9719d532d6e866956062a3d8ad437781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::recoverResources </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;&#160;</td>
          <td class="paramname"><em>resources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers resources. </p>
<p>Used to update the set of available resources for a specific agent. This method is invoked to inform the allocator about allocated resources that have been refused or are no longer in use. Allocated resources will have an <code>allocation_info.role</code> assigned and callers are expected to only call this with resources allocated to a single role.</p>
<p>TODO(bmahler): We could allow resources allocated to multiple roles within a single call here, but filtering them in the same way does not seem desirable. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a862c015739e0b536ac5ad206df1bd265">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac58e3a3025d3887ab1ab9267c9093188"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::removeFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a framework from the Mesos cluster. </p>
<p>It is up to an allocator to decide what to do with framework's resources. For example, they may be released and added back to the shared pool of resources. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a23724d1a04045cf433dc3d7c4e8ea44c">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7c4fb581525a58eaea748afaa87ccb40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::removeQuota </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the allocator to remove quota for the given role. </p>
<p>An allocator implementation may employ different strategies for roles with or without quota. Hence an empty (or zero) quota is not necessarily the same as an absence of quota. Logically, this method implies that the given role should be transitioned to the group of roles without quota set (absence of quota). An allocator implementation may assert quota for the given role is set prior to the call and react accordingly if this assumption is violated (i.e. fail).</p>
<p>TODO(alexr): Consider returning a future which an allocator can fail in order to report failure. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#adcb5555297656e9361c1da3230785a5c">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7193bcacb52eaec201bf88e95f03acad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::removeSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an agent from the Mesos cluster. </p>
<p>All resources belonging to this agent should be released by the allocator. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#aa668a3cac81d97424ff4ec517ca21b23">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6d1124aace866719ed1e9ed45a068412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::requestResources </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests resources for a framework. </p>
<p>A framework may request resources via this call. It is up to the allocator how to react to this request. For example, a request may be ignored, or may influence internal priorities the allocator may keep for frameworks. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a0eba8f165dd5c4aa24a5ec14633c64a8">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2199d77c20843a5aa04b11c9bd93867d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::reviveOffers </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Revives offers to this framework for the specified role. </p>
<p>This is invoked by a framework when it wishes to receive filtered resources immediately or get itself out of a suppressed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">role</td><td>The optional role parameter allows frameworks with multiple roles to do fine-grained revival. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a64a000dcbccd66f526c737048540f89f">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a06d46d24d46f7c9858ab58c027ecc7ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::setQuota </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structQuota.html">Quota</a> &amp;&#160;</td>
          <td class="paramname"><em>quota</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the allocator to set quota for the given role. </p>
<p>It is up to the allocator implementation how to satisfy quota. An implementation may employ different strategies for roles with or without quota. Hence an empty (or zero) quota is not necessarily the same as an absence of quota. Logically, this method implies that the given role should be transitioned to the group of roles with quota set. An allocator implementation may assert quota for the given role is not set prior to the call and react accordingly if this assumption is violated (i.e. fail).</p>
<p>TODO(alexr): Consider returning a future which an allocator can fail in order to report failure.</p>
<p>TODO(alexr): Consider adding an <code>updateQuota()</code> method which allows updating existing quota. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a438b5c7c52813573cd63ec14623c3c39">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a768bf53dbae88340e7f048659490ef2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::suppressOffers </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suppresses offers. </p>
<p>Informs the allocator to stop sending offers to this framework for the specified role. If the role is not specified, we will stop sending offers to this framework for all of its roles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">role</td><td>The optional role parameter allows frameworks with multiple roles to do fine-grained suppression. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#aabb6453a9505f8190b6a6a3331393fa4">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a42f405bd54c1c1782a388cb28ca58b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::updateAllocation </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;&#160;</td>
          <td class="paramname"><em>offeredResources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Offer::Operation &gt; &amp;&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates allocation by applying offer operations. </p>
<p>This call is mainly intended to support persistence-related features (dynamic reservation and persistent volumes). The allocator may react differently for certain offer operations. The allocator should use this call to update bookkeeping information related to the framework. The <code>offeredResources</code> are the resources that the operations are applied to and must be allocated to a single role. </p>

</div>
</div>
<a class="anchor" id="a997ec43933a7659b683d83c164bdd6db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt;<a class="el" href="structNothing.html">Nothing</a>&gt; mesos::allocator::Allocator::updateAvailable </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Offer::Operation &gt; &amp;&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates available resources on an agent based on a sequence of offer operations. </p>
<p>Operations may include reserve, unreserve, create or destroy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slaveId</td><td>ID of the agent. </td></tr>
    <tr><td class="paramname">operations</td><td>The offer operations to apply to this agent's resources. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55e33c8def42553ba5435809dcae5b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::updateFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameworkInfo &amp;&#160;</td>
          <td class="paramname"><em>frameworkInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates capabilities of a framework in the Mesos cluster. </p>
<p>This will be invoked when a framework is re-added. As some of the framework's capabilities may be updated when re-added, this API should update the capabilities of the newly added framework to Mesos cluster to reflect the latest framework info. Please refer to the design document here <a href="https://cwiki.apache.org/confluence/display/MESOS/Design+doc:+Updating+Framework+Info">https://cwiki.apache.org/confluence/display/MESOS/Design+doc:+Updating+Framework+Info</a> // NOLINT for more details related to framework update. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a8e3f9229ea3637cc6ab3a46ecab9c7f7">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9b03a500abdf2f677f3fd9ea958d0690"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::updateInverseOffer </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unavailableResources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; InverseOfferStatus &gt; &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em> = <code><a class="el" href="structNone.html">None</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates inverse offer. </p>
<p>Informs the allocator that the inverse offer has been responded to or revoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unavailableResources</td><td>The <code>unavailableResources</code> can be used by the allocator to distinguish between different inverse offers sent to the same framework for the same slave. </td></tr>
    <tr><td class="paramname">status</td><td>If <code>status</code> is not set then the inverse offer was not responded to, possibly because the offer timed out or was rescinded. This might require the implementation of the function to remove any inverse offers that are outstanding. </td></tr>
    <tr><td class="paramname">filters</td><td>A filter attached to the inverse offer can be used by the framework to control when it wants to be contacted again with the inverse offer. The "filters" for InverseOffers are identical to the existing mechanism for re-offering Offers to frameworks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afeb21abe14f83ee609f459973bd31b05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::updateSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>oversubscribed</em> = <code><a class="el" href="structNone.html">None</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::vector&lt; SlaveInfo::Capability &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em> = <code><a class="el" href="structNone.html">None</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates an agent. </p>
<p>Updates the latest oversubscribed resources or capabilities for an agent. TODO(vinod): Instead of just oversubscribed resources have this method take total resources. We can then reuse this method to update Agent's total resources in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oversubscribed</td><td>The new oversubscribed resources estimate from the agent. The oversubscribed resources include the total amount of oversubscribed resources that are allocated and available. </td></tr>
    <tr><td class="paramname">capabilities</td><td>The new capabilities of the agent. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#abd259d23b89536a11900e7e1be70905c">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a455bb50eb4548484969c42ada23cd8ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::updateUnavailability </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;&#160;</td>
          <td class="paramname"><em>unavailability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates unavailability for an agent. </p>
<p>We currently support storing the next unavailability, if there is one, per agent. If <code>unavailability</code> is not set then there is no known upcoming unavailability. This might require the implementation of the function to remove any inverse offers that are outstanding. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a08403df603e11aacc3dcadab5cae4940">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a36ed11fe06b6565b72c57ee9a88439f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::updateWeights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; WeightInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>weightInfos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the weight associated with one or more roles. </p>
<p>If a role was previously configured to have a weight and that role is omitted from this list, it keeps its old weight. </p>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a64aebea886bb0148defbbc1ce936e0a3">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a961049fd776211cc762ad0e1e1c99321"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mesos::allocator::Allocator::updateWhitelist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classhashset.html">hashset</a>&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>whitelist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the list of trusted agents. </p>
<p>This is invoked when the master starts up with the &ndash;whitelist flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whitelist</td><td>A set of agents that are allowed to contribute their resources to the resource pool. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#adb63887ce887bbff1179e717e0abdeb3">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mesos/allocator/<a class="el" href="include_2mesos_2allocator_2allocator_8hpp_source.html">allocator.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
