<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Apache Mesos: mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemesos.html">mesos</a></li><li class="navelem"><a class="el" href="namespacemesos_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="namespacemesos_1_1internal_1_1master.html">master</a></li><li class="navelem"><a class="el" href="namespacemesos_1_1internal_1_1master_1_1allocator.html">allocator</a></li><li class="navelem"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">MesosAllocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="src_2master_2allocator_2mesos_2allocator_8hpp_source.html">allocator.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.png" usemap="#mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;_map" alt=""/>
  <map id="mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;_map" name="mesos::internal::master::allocator::MesosAllocator&lt; AllocatorProcess &gt;_map">
<area href="classmesos_1_1allocator_1_1Allocator.html" title="Basic model of an allocator: resources are allocated to a framework in the form of offers..." alt="mesos::allocator::Allocator" shape="rect" coords="0,0,408,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f92440e352e4345bf6cd813dc2313f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a9f92440e352e4345bf6cd813dc2313f3">~MesosAllocator</a> ()</td></tr>
<tr class="separator:a9f92440e352e4345bf6cd813dc2313f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af156a0733bc92af96852aa09df8138b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af156a0733bc92af96852aa09df8138b5">initialize</a> (const <a class="el" href="classDuration.html">Duration</a> &amp;allocationInterval, const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt;&gt; &amp;)&gt; &amp;offerCallback, const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;)&gt; &amp;inverseOfferCallback, const <a class="el" href="classOption.html">Option</a>&lt; std::set&lt; std::string &gt;&gt; &amp;fairnessExcludeResourceNames=<a class="el" href="structNone.html">None</a>())</td></tr>
<tr class="memdesc:af156a0733bc92af96852aa09df8138b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the allocator when the master starts up.  <a href="#af156a0733bc92af96852aa09df8138b5">More...</a><br/></td></tr>
<tr class="separator:af156a0733bc92af96852aa09df8138b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e6a84a1dc03b531897ea1ee7745f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#aa38e6a84a1dc03b531897ea1ee7745f1">recover</a> (const int expectedAgentCount, const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="structQuota.html">Quota</a> &gt; &amp;quotas)</td></tr>
<tr class="memdesc:aa38e6a84a1dc03b531897ea1ee7745f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the allocator of the recovered state from the master.  <a href="#aa38e6a84a1dc03b531897ea1ee7745f1">More...</a><br/></td></tr>
<tr class="separator:aa38e6a84a1dc03b531897ea1ee7745f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bada3270698413305fa2dd8cabca97f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a2bada3270698413305fa2dd8cabca97f">addFramework</a> (const FrameworkID &amp;frameworkId, const FrameworkInfo &amp;frameworkInfo, const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;used, bool active)</td></tr>
<tr class="memdesc:a2bada3270698413305fa2dd8cabca97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a framework to the Mesos cluster.  <a href="#a2bada3270698413305fa2dd8cabca97f">More...</a><br/></td></tr>
<tr class="separator:a2bada3270698413305fa2dd8cabca97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23724d1a04045cf433dc3d7c4e8ea44c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a23724d1a04045cf433dc3d7c4e8ea44c">removeFramework</a> (const FrameworkID &amp;frameworkId)</td></tr>
<tr class="memdesc:a23724d1a04045cf433dc3d7c4e8ea44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a framework from the Mesos cluster.  <a href="#a23724d1a04045cf433dc3d7c4e8ea44c">More...</a><br/></td></tr>
<tr class="separator:a23724d1a04045cf433dc3d7c4e8ea44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3d9588e381592d7f3a7033c87e8023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a5b3d9588e381592d7f3a7033c87e8023">activateFramework</a> (const FrameworkID &amp;frameworkId)</td></tr>
<tr class="memdesc:a5b3d9588e381592d7f3a7033c87e8023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates a framework in the Mesos cluster.  <a href="#a5b3d9588e381592d7f3a7033c87e8023">More...</a><br/></td></tr>
<tr class="separator:a5b3d9588e381592d7f3a7033c87e8023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bfe097b00b97e71e75bf34d2ee12b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#ab6bfe097b00b97e71e75bf34d2ee12b4">deactivateFramework</a> (const FrameworkID &amp;frameworkId)</td></tr>
<tr class="memdesc:ab6bfe097b00b97e71e75bf34d2ee12b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivates a framework in the Mesos cluster.  <a href="#ab6bfe097b00b97e71e75bf34d2ee12b4">More...</a><br/></td></tr>
<tr class="separator:ab6bfe097b00b97e71e75bf34d2ee12b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3f9229ea3637cc6ab3a46ecab9c7f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a8e3f9229ea3637cc6ab3a46ecab9c7f7">updateFramework</a> (const FrameworkID &amp;frameworkId, const FrameworkInfo &amp;frameworkInfo)</td></tr>
<tr class="memdesc:a8e3f9229ea3637cc6ab3a46ecab9c7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates capabilities of a framework in the Mesos cluster.  <a href="#a8e3f9229ea3637cc6ab3a46ecab9c7f7">More...</a><br/></td></tr>
<tr class="separator:a8e3f9229ea3637cc6ab3a46ecab9c7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21d8b1c164feddfc6a8550245028b06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af21d8b1c164feddfc6a8550245028b06">addSlave</a> (const SlaveID &amp;slaveId, const SlaveInfo &amp;slaveInfo, const std::vector&lt; SlaveInfo::Capability &gt; &amp;capabilities, const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;unavailability, const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;total, const <a class="el" href="classhashmap.html">hashmap</a>&lt; FrameworkID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;used)</td></tr>
<tr class="memdesc:af21d8b1c164feddfc6a8550245028b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or re-adds an agent to the Mesos cluster.  <a href="#af21d8b1c164feddfc6a8550245028b06">More...</a><br/></td></tr>
<tr class="separator:af21d8b1c164feddfc6a8550245028b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa668a3cac81d97424ff4ec517ca21b23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#aa668a3cac81d97424ff4ec517ca21b23">removeSlave</a> (const SlaveID &amp;slaveId)</td></tr>
<tr class="memdesc:aa668a3cac81d97424ff4ec517ca21b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an agent from the Mesos cluster.  <a href="#aa668a3cac81d97424ff4ec517ca21b23">More...</a><br/></td></tr>
<tr class="separator:aa668a3cac81d97424ff4ec517ca21b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd259d23b89536a11900e7e1be70905c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#abd259d23b89536a11900e7e1be70905c">updateSlave</a> (const SlaveID &amp;slave, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;oversubscribed=<a class="el" href="structNone.html">None</a>(), const <a class="el" href="classOption.html">Option</a>&lt; std::vector&lt; SlaveInfo::Capability &gt;&gt; &amp;capabilities=<a class="el" href="structNone.html">None</a>())</td></tr>
<tr class="memdesc:abd259d23b89536a11900e7e1be70905c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an agent.  <a href="#abd259d23b89536a11900e7e1be70905c">More...</a><br/></td></tr>
<tr class="separator:abd259d23b89536a11900e7e1be70905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839be3c9f14c390cd92e9a4fde43065b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a839be3c9f14c390cd92e9a4fde43065b">activateSlave</a> (const SlaveID &amp;slaveId)</td></tr>
<tr class="memdesc:a839be3c9f14c390cd92e9a4fde43065b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates an agent.  <a href="#a839be3c9f14c390cd92e9a4fde43065b">More...</a><br/></td></tr>
<tr class="separator:a839be3c9f14c390cd92e9a4fde43065b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ff01f9c80915a5c2db609fcfd466c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af67ff01f9c80915a5c2db609fcfd466c">deactivateSlave</a> (const SlaveID &amp;slaveId)</td></tr>
<tr class="memdesc:af67ff01f9c80915a5c2db609fcfd466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivates an agent.  <a href="#af67ff01f9c80915a5c2db609fcfd466c">More...</a><br/></td></tr>
<tr class="separator:af67ff01f9c80915a5c2db609fcfd466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb63887ce887bbff1179e717e0abdeb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#adb63887ce887bbff1179e717e0abdeb3">updateWhitelist</a> (const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classhashset.html">hashset</a>&lt; std::string &gt;&gt; &amp;whitelist)</td></tr>
<tr class="memdesc:adb63887ce887bbff1179e717e0abdeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the list of trusted agents.  <a href="#adb63887ce887bbff1179e717e0abdeb3">More...</a><br/></td></tr>
<tr class="separator:adb63887ce887bbff1179e717e0abdeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eba8f165dd5c4aa24a5ec14633c64a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a0eba8f165dd5c4aa24a5ec14633c64a8">requestResources</a> (const FrameworkID &amp;frameworkId, const std::vector&lt; Request &gt; &amp;requests)</td></tr>
<tr class="memdesc:a0eba8f165dd5c4aa24a5ec14633c64a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests resources for a framework.  <a href="#a0eba8f165dd5c4aa24a5ec14633c64a8">More...</a><br/></td></tr>
<tr class="separator:a0eba8f165dd5c4aa24a5ec14633c64a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10991500ffd040989b955c9c3c5899b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#ae10991500ffd040989b955c9c3c5899b">updateAllocation</a> (const FrameworkID &amp;frameworkId, const SlaveID &amp;slaveId, const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;offeredResources, const std::vector&lt; Offer::Operation &gt; &amp;operations)</td></tr>
<tr class="separator:ae10991500ffd040989b955c9c3c5899b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac10ddce3a1a07ecdea7cbcac00bde9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt; <a class="el" href="structNothing.html">Nothing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a1ac10ddce3a1a07ecdea7cbcac00bde9">updateAvailable</a> (const SlaveID &amp;slaveId, const std::vector&lt; Offer::Operation &gt; &amp;operations)</td></tr>
<tr class="separator:a1ac10ddce3a1a07ecdea7cbcac00bde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08403df603e11aacc3dcadab5cae4940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a08403df603e11aacc3dcadab5cae4940">updateUnavailability</a> (const SlaveID &amp;slaveId, const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;unavailability)</td></tr>
<tr class="memdesc:a08403df603e11aacc3dcadab5cae4940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates unavailability for an agent.  <a href="#a08403df603e11aacc3dcadab5cae4940">More...</a><br/></td></tr>
<tr class="separator:a08403df603e11aacc3dcadab5cae4940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c199417a36337e98d3faeefedd7c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#afd7c199417a36337e98d3faeefedd7c9">updateInverseOffer</a> (const SlaveID &amp;slaveId, const FrameworkID &amp;frameworkId, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;unavailableResources, const <a class="el" href="classOption.html">Option</a>&lt; mesos::allocator::InverseOfferStatus &gt; &amp;status, const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;filters)</td></tr>
<tr class="separator:afd7c199417a36337e98d3faeefedd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c99e1ef89e81035b1e3656ca632628f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt; <a class="el" href="classhashmap.html">hashmap</a><br class="typebreak"/>
&lt; SlaveID, <a class="el" href="classhashmap.html">hashmap</a><br class="typebreak"/>
&lt; FrameworkID, <br class="typebreak"/>
mesos::allocator::InverseOfferStatus &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a9c99e1ef89e81035b1e3656ca632628f">getInverseOfferStatuses</a> ()</td></tr>
<tr class="memdesc:a9c99e1ef89e81035b1e3656ca632628f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the status of all inverse offers maintained by the allocator.  <a href="#a9c99e1ef89e81035b1e3656ca632628f">More...</a><br/></td></tr>
<tr class="separator:a9c99e1ef89e81035b1e3656ca632628f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862c015739e0b536ac5ad206df1bd265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a862c015739e0b536ac5ad206df1bd265">recoverResources</a> (const FrameworkID &amp;frameworkId, const SlaveID &amp;slaveId, const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;resources, const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;filters)</td></tr>
<tr class="memdesc:a862c015739e0b536ac5ad206df1bd265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers resources.  <a href="#a862c015739e0b536ac5ad206df1bd265">More...</a><br/></td></tr>
<tr class="separator:a862c015739e0b536ac5ad206df1bd265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb6453a9505f8190b6a6a3331393fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#aabb6453a9505f8190b6a6a3331393fa4">suppressOffers</a> (const FrameworkID &amp;frameworkId, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;role)</td></tr>
<tr class="memdesc:aabb6453a9505f8190b6a6a3331393fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppresses offers.  <a href="#aabb6453a9505f8190b6a6a3331393fa4">More...</a><br/></td></tr>
<tr class="separator:aabb6453a9505f8190b6a6a3331393fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a000dcbccd66f526c737048540f89f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a64a000dcbccd66f526c737048540f89f">reviveOffers</a> (const FrameworkID &amp;frameworkId, const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;role)</td></tr>
<tr class="memdesc:a64a000dcbccd66f526c737048540f89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revives offers to this framework for the specified role.  <a href="#a64a000dcbccd66f526c737048540f89f">More...</a><br/></td></tr>
<tr class="separator:a64a000dcbccd66f526c737048540f89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438b5c7c52813573cd63ec14623c3c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a438b5c7c52813573cd63ec14623c3c39">setQuota</a> (const std::string &amp;role, const <a class="el" href="structQuota.html">Quota</a> &amp;quota)</td></tr>
<tr class="memdesc:a438b5c7c52813573cd63ec14623c3c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the allocator to set quota for the given role.  <a href="#a438b5c7c52813573cd63ec14623c3c39">More...</a><br/></td></tr>
<tr class="separator:a438b5c7c52813573cd63ec14623c3c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb5555297656e9361c1da3230785a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#adcb5555297656e9361c1da3230785a5c">removeQuota</a> (const std::string &amp;role)</td></tr>
<tr class="memdesc:adcb5555297656e9361c1da3230785a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the allocator to remove quota for the given role.  <a href="#adcb5555297656e9361c1da3230785a5c">More...</a><br/></td></tr>
<tr class="separator:adcb5555297656e9361c1da3230785a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64aebea886bb0148defbbc1ce936e0a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a64aebea886bb0148defbbc1ce936e0a3">updateWeights</a> (const std::vector&lt; WeightInfo &gt; &amp;weightInfos)</td></tr>
<tr class="memdesc:a64aebea886bb0148defbbc1ce936e0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the weight associated with one or more roles.  <a href="#a64aebea886bb0148defbbc1ce936e0a3">More...</a><br/></td></tr>
<tr class="separator:a64aebea886bb0148defbbc1ce936e0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmesos_1_1allocator_1_1Allocator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmesos_1_1allocator_1_1Allocator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmesos_1_1allocator_1_1Allocator.html">mesos::allocator::Allocator</a></td></tr>
<tr class="memitem:aafc715605c23a31dcb511a6b5c2ac883 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#aafc715605c23a31dcb511a6b5c2ac883">Allocator</a> ()</td></tr>
<tr class="separator:aafc715605c23a31dcb511a6b5c2ac883 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32e61251f0e0cbc9588c04e98347a3 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a8b32e61251f0e0cbc9588c04e98347a3">~Allocator</a> ()</td></tr>
<tr class="separator:a8b32e61251f0e0cbc9588c04e98347a3 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f405bd54c1c1782a388cb28ca58b42 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a42f405bd54c1c1782a388cb28ca58b42">updateAllocation</a> (const FrameworkID &amp;frameworkId, const SlaveID &amp;slaveId, const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;offeredResources, const std::vector&lt; Offer::Operation &gt; &amp;operations)=0</td></tr>
<tr class="memdesc:a42f405bd54c1c1782a388cb28ca58b42 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates allocation by applying offer operations.  <a href="#a42f405bd54c1c1782a388cb28ca58b42">More...</a><br/></td></tr>
<tr class="separator:a42f405bd54c1c1782a388cb28ca58b42 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997ec43933a7659b683d83c164bdd6db inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt; <a class="el" href="structNothing.html">Nothing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a997ec43933a7659b683d83c164bdd6db">updateAvailable</a> (const SlaveID &amp;slaveId, const std::vector&lt; Offer::Operation &gt; &amp;operations)=0</td></tr>
<tr class="memdesc:a997ec43933a7659b683d83c164bdd6db inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates available resources on an agent based on a sequence of offer operations.  <a href="#a997ec43933a7659b683d83c164bdd6db">More...</a><br/></td></tr>
<tr class="separator:a997ec43933a7659b683d83c164bdd6db inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b03a500abdf2f677f3fd9ea958d0690 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a9b03a500abdf2f677f3fd9ea958d0690">updateInverseOffer</a> (const SlaveID &amp;slaveId, const FrameworkID &amp;frameworkId, const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;unavailableResources, const <a class="el" href="classOption.html">Option</a>&lt; InverseOfferStatus &gt; &amp;status, const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;filters=<a class="el" href="structNone.html">None</a>())=0</td></tr>
<tr class="memdesc:a9b03a500abdf2f677f3fd9ea958d0690 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates inverse offer.  <a href="#a9b03a500abdf2f677f3fd9ea958d0690">More...</a><br/></td></tr>
<tr class="separator:a9b03a500abdf2f677f3fd9ea958d0690 inherit pub_methods_classmesos_1_1allocator_1_1Allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acffe93fb6ad2962eb231404a13295b83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTry.html">Try</a><br class="typebreak"/>
&lt; <a class="el" href="classmesos_1_1allocator_1_1Allocator.html">mesos::allocator::Allocator</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#acffe93fb6ad2962eb231404a13295b83">create</a> ()</td></tr>
<tr class="separator:acffe93fb6ad2962eb231404a13295b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmesos_1_1allocator_1_1Allocator"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmesos_1_1allocator_1_1Allocator')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmesos_1_1allocator_1_1Allocator.html">mesos::allocator::Allocator</a></td></tr>
<tr class="memitem:ae12461b03c88e6fce8528488b50a47f5 inherit pub_static_methods_classmesos_1_1allocator_1_1Allocator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTry.html">Try</a>&lt; <a class="el" href="classmesos_1_1allocator_1_1Allocator.html">Allocator</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmesos_1_1allocator_1_1Allocator.html#ae12461b03c88e6fce8528488b50a47f5">create</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae12461b03c88e6fce8528488b50a47f5 inherit pub_static_methods_classmesos_1_1allocator_1_1Allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts either to create a built-in DRF allocator or to load an allocator instance from a module using the given name.  <a href="#ae12461b03c88e6fce8528488b50a47f5">More...</a><br/></td></tr>
<tr class="separator:ae12461b03c88e6fce8528488b50a47f5 inherit pub_static_methods_classmesos_1_1allocator_1_1Allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9f92440e352e4345bf6cd813dc2313f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::~<a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">MesosAllocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5b3d9588e381592d7f3a7033c87e8023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::activateFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activates a framework in the Mesos cluster. </p>
<p>Offers are only sent to active frameworks. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a60b5e4ab25ef87eb74763c10cfc21850">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a839be3c9f14c390cd92e9a4fde43065b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::activateSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activates an agent. </p>
<p>This is invoked when an agent reregisters. Offers are only sent for activated agents. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a2469bc7c28ab20a86cd2d198dd99e2cd">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a2bada3270698413305fa2dd8cabca97f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::addFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameworkInfo &amp;&#160;</td>
          <td class="paramname"><em>frameworkInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a framework to the Mesos cluster. </p>
<p>The allocator is invoked when a new framework joins the Mesos cluster and is entitled to participate in resource sharing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">used</td><td><a class="el" href="classmesos_1_1Resources.html">Resources</a> used by this framework. The allocator should account for these resources when updating the allocation of this framework. The allocator should avoid double accounting when yet unknown agents are added later in <code><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af21d8b1c164feddfc6a8550245028b06" title="Adds or re-adds an agent to the Mesos cluster. ">addSlave()</a></code>.</td></tr>
    <tr><td class="paramname">active</td><td>Whether the framework is initially activated. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a8dbc103b21872ed885a45ac3d928c83d">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="af21d8b1c164feddfc6a8550245028b06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::addSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlaveInfo &amp;&#160;</td>
          <td class="paramname"><em>slaveInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SlaveInfo::Capability &gt; &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;&#160;</td>
          <td class="paramname"><em>unavailability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhashmap.html">hashmap</a>&lt; FrameworkID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds or re-adds an agent to the Mesos cluster. </p>
<p>It is invoked when a new agent joins the cluster or in case of agent recovery.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slaveId</td><td>ID of the agent to be added or re-added. </td></tr>
    <tr><td class="paramname">slaveInfo</td><td>Detailed info of the agent. The slaveInfo resources correspond directly to the static &ndash;resources flag value on the agent. </td></tr>
    <tr><td class="paramname">capabilities</td><td>Capabilities of the agent. </td></tr>
    <tr><td class="paramname">total</td><td>The <code>total</code> resources are passed explicitly because it includes resources that are dynamically "checkpointed" on the agent (e.g. persistent volumes, dynamic reservations, etc). </td></tr>
    <tr><td class="paramname">used</td><td><a class="el" href="classmesos_1_1Resources.html">Resources</a> that are allocated on the current agent. The allocator should avoid double accounting when yet unknown frameworks are added later in <code><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#a2bada3270698413305fa2dd8cabca97f" title="Adds a framework to the Mesos cluster. ">addFramework()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a12346eed9894458805e180b9d6cb6424">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="acffe93fb6ad2962eb231404a13295b83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTry.html">Try</a>&lt; <a class="el" href="classmesos_1_1allocator_1_1Allocator.html">mesos::allocator::Allocator</a> * &gt; <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6bfe097b00b97e71e75bf34d2ee12b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::deactivateFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deactivates a framework in the Mesos cluster. </p>
<p>Resource offers are not sent to deactivated frameworks. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#afe9d8fc901322dde7d91037930c77f72">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="af67ff01f9c80915a5c2db609fcfd466c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::deactivateSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deactivates an agent. </p>
<p>This is triggered if an agent disconnects from the master. The allocator should treat all offers from the deactivated agent as rescinded. (There is no separate call to the allocator to handle this). <a class="el" href="classmesos_1_1Resources.html">Resources</a> aren't "recovered" when an agent deactivates because the resources are lost. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a4dff6ddc4983c5495eb2fc26e2842114">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a9c99e1ef89e81035b1e3656ca632628f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt; <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classhashmap.html">hashmap</a>&lt; FrameworkID, mesos::allocator::InverseOfferStatus &gt; &gt; &gt; <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::getInverseOfferStatuses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the status of all inverse offers maintained by the allocator. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#af09ffe12fe6dce0bb115d9988ddb61d1">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="af156a0733bc92af96852aa09df8138b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDuration.html">Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>allocationInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt;&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>offerCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda::function&lt; void(const FrameworkID &amp;, const <a class="el" href="classhashmap.html">hashmap</a>&lt; SlaveID, <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inverseOfferCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::set&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fairnessExcludeResourceNames</em> = <code><a class="el" href="structNone.html">None</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the allocator when the master starts up. </p>
<p>Any errors in initialization should fail fast and result in an ABORT. The master expects the allocator to be successfully initialized if this call returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocationInterval</td><td>The allocate interval for the allocator, it determines how often the allocator should perform the batch allocation. An allocator may also perform allocation based on events (a framework is added and so on), this depends on the implementation. </td></tr>
    <tr><td class="paramname">offerCallback</td><td>A callback the allocator uses to send allocations to the frameworks. </td></tr>
    <tr><td class="paramname">inverseOfferCallback</td><td>A callback the allocator uses to send reclaim allocations from the frameworks. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#ab813725216eb1fdfc62b4e3f61c044f2">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="aa38e6a84a1dc03b531897ea1ee7745f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::recover </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>expectedAgentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhashmap.html">hashmap</a>&lt; std::string, <a class="el" href="structQuota.html">Quota</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quotas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the allocator of the recovered state from the master. </p>
<p>Because it is hard to define recovery for a running allocator, this method should be called after <code><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af156a0733bc92af96852aa09df8138b5" title="Initializes the allocator when the master starts up. ">initialize()</a></code>, but before actual allocation starts (i.e. <code><a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html#af21d8b1c164feddfc6a8550245028b06" title="Adds or re-adds an agent to the Mesos cluster. ">addSlave()</a></code> is called).</p>
<p>TODO(alexr): Consider extending the signature with expected frameworks count once it is available upon the master failover.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quotas</td><td>A (possibly empty) collection of quotas, keyed by their role, known to the master. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#abe1f158adb9f7a6d7cc9f8afae44e859">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a862c015739e0b536ac5ad206df1bd265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::recoverResources </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;&#160;</td>
          <td class="paramname"><em>resources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers resources. </p>
<p>Used to update the set of available resources for a specific agent. This method is invoked to inform the allocator about allocated resources that have been refused or are no longer in use. Allocated resources will have an <code>allocation_info.role</code> assigned and callers are expected to only call this with resources allocated to a single role.</p>
<p>TODO(bmahler): We could allow resources allocated to multiple roles within a single call here, but filtering them in the same way does not seem desirable. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a9719d532d6e866956062a3d8ad437781">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a23724d1a04045cf433dc3d7c4e8ea44c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::removeFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a framework from the Mesos cluster. </p>
<p>It is up to an allocator to decide what to do with framework's resources. For example, they may be released and added back to the shared pool of resources. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#ac58e3a3025d3887ab1ab9267c9093188">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="adcb5555297656e9361c1da3230785a5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::removeQuota </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the allocator to remove quota for the given role. </p>
<p>An allocator implementation may employ different strategies for roles with or without quota. Hence an empty (or zero) quota is not necessarily the same as an absence of quota. Logically, this method implies that the given role should be transitioned to the group of roles without quota set (absence of quota). An allocator implementation may assert quota for the given role is set prior to the call and react accordingly if this assumption is violated (i.e. fail).</p>
<p>TODO(alexr): Consider returning a future which an allocator can fail in order to report failure. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a7c4fb581525a58eaea748afaa87ccb40">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="aa668a3cac81d97424ff4ec517ca21b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::removeSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an agent from the Mesos cluster. </p>
<p>All resources belonging to this agent should be released by the allocator. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a7193bcacb52eaec201bf88e95f03acad">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a0eba8f165dd5c4aa24a5ec14633c64a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::requestResources </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests resources for a framework. </p>
<p>A framework may request resources via this call. It is up to the allocator how to react to this request. For example, a request may be ignored, or may influence internal priorities the allocator may keep for frameworks. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a6d1124aace866719ed1e9ed45a068412">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a64a000dcbccd66f526c737048540f89f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::reviveOffers </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Revives offers to this framework for the specified role. </p>
<p>This is invoked by a framework when it wishes to receive filtered resources immediately or get itself out of a suppressed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">role</td><td>The optional role parameter allows frameworks with multiple roles to do fine-grained revival. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a2199d77c20843a5aa04b11c9bd93867d">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a438b5c7c52813573cd63ec14623c3c39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::setQuota </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structQuota.html">Quota</a> &amp;&#160;</td>
          <td class="paramname"><em>quota</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the allocator to set quota for the given role. </p>
<p>It is up to the allocator implementation how to satisfy quota. An implementation may employ different strategies for roles with or without quota. Hence an empty (or zero) quota is not necessarily the same as an absence of quota. Logically, this method implies that the given role should be transitioned to the group of roles with quota set. An allocator implementation may assert quota for the given role is not set prior to the call and react accordingly if this assumption is violated (i.e. fail).</p>
<p>TODO(alexr): Consider returning a future which an allocator can fail in order to report failure.</p>
<p>TODO(alexr): Consider adding an <code>updateQuota()</code> method which allows updating existing quota. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a06d46d24d46f7c9858ab58c027ecc7ca">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="aabb6453a9505f8190b6a6a3331393fa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::suppressOffers </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suppresses offers. </p>
<p>Informs the allocator to stop sending offers to this framework for the specified role. If the role is not specified, we will stop sending offers to this framework for all of its roles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">role</td><td>The optional role parameter allows frameworks with multiple roles to do fine-grained suppression. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a768bf53dbae88340e7f048659490ef2b">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="ae10991500ffd040989b955c9c3c5899b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateAllocation </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmesos_1_1Resources.html">Resources</a> &amp;&#160;</td>
          <td class="paramname"><em>offeredResources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Offer::Operation &gt; &amp;&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ac10ddce3a1a07ecdea7cbcac00bde9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">process::Future</a>&lt; <a class="el" href="structNothing.html">Nothing</a> &gt; <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateAvailable </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Offer::Operation &gt; &amp;&#160;</td>
          <td class="paramname"><em>operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e3f9229ea3637cc6ab3a46ecab9c7f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateFramework </td>
          <td>(</td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameworkInfo &amp;&#160;</td>
          <td class="paramname"><em>frameworkInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates capabilities of a framework in the Mesos cluster. </p>
<p>This will be invoked when a framework is re-added. As some of the framework's capabilities may be updated when re-added, this API should update the capabilities of the newly added framework to Mesos cluster to reflect the latest framework info. Please refer to the design document here <a href="https://cwiki.apache.org/confluence/display/MESOS/Design+doc:+Updating+Framework+Info">https://cwiki.apache.org/confluence/display/MESOS/Design+doc:+Updating+Framework+Info</a> // NOLINT for more details related to framework update. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a55e33c8def42553ba5435809dcae5b0a">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="afd7c199417a36337e98d3faeefedd7c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateInverseOffer </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameworkID &amp;&#160;</td>
          <td class="paramname"><em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="structmesos_1_1UnavailableResources.html">UnavailableResources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unavailableResources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; mesos::allocator::InverseOfferStatus &gt; &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Filters &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd259d23b89536a11900e7e1be70905c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateSlave </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classmesos_1_1Resources.html">Resources</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>oversubscribed</em> = <code><a class="el" href="structNone.html">None</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; std::vector&lt; SlaveInfo::Capability &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>capabilities</em> = <code><a class="el" href="structNone.html">None</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates an agent. </p>
<p>Updates the latest oversubscribed resources or capabilities for an agent. TODO(vinod): Instead of just oversubscribed resources have this method take total resources. We can then reuse this method to update Agent's total resources in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oversubscribed</td><td>The new oversubscribed resources estimate from the agent. The oversubscribed resources include the total amount of oversubscribed resources that are allocated and available. </td></tr>
    <tr><td class="paramname">capabilities</td><td>The new capabilities of the agent. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#afeb21abe14f83ee609f459973bd31b05">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a08403df603e11aacc3dcadab5cae4940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateUnavailability </td>
          <td>(</td>
          <td class="paramtype">const SlaveID &amp;&#160;</td>
          <td class="paramname"><em>slaveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; Unavailability &gt; &amp;&#160;</td>
          <td class="paramname"><em>unavailability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates unavailability for an agent. </p>
<p>We currently support storing the next unavailability, if there is one, per agent. If <code>unavailability</code> is not set then there is no known upcoming unavailability. This might require the implementation of the function to remove any inverse offers that are outstanding. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a455bb50eb4548484969c42ada23cd8ff">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a64aebea886bb0148defbbc1ce936e0a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateWeights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; WeightInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>weightInfos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the weight associated with one or more roles. </p>
<p>If a role was previously configured to have a weight and that role is omitted from this list, it keeps its old weight. </p>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a36ed11fe06b6565b72c57ee9a88439f5">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="adb63887ce887bbff1179e717e0abdeb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocatorProcess &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmesos_1_1internal_1_1master_1_1allocator_1_1MesosAllocator.html">mesos::internal::master::allocator::MesosAllocator</a>&lt; AllocatorProcess &gt;::updateWhitelist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOption.html">Option</a>&lt; <a class="el" href="classhashset.html">hashset</a>&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>whitelist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the list of trusted agents. </p>
<p>This is invoked when the master starts up with the &ndash;whitelist flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whitelist</td><td>A set of agents that are allowed to contribute their resources to the resource pool. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmesos_1_1allocator_1_1Allocator.html#a961049fd776211cc762ad0e1e1c99321">mesos::allocator::Allocator</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/master/allocator/mesos/<a class="el" href="src_2master_2allocator_2mesos_2allocator_8hpp_source.html">allocator.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
